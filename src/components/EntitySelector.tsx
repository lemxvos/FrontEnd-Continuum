/**\n * ENTITY SELECTOR\n * \n * Autocomplete para selecionar entidades e inserir como menção\n * \n * FLUXO:\n * 1. Usuário digita no editor: \"Saí com {pe\"\n * 2. Componente detecta o padrão {pe\n * 3. Busca entidades que começam com \"pe\"\n * 4. Mostra dropdown com sugestões\n * 5. Usuário clica ou pressiona Enter\n * 6. Frontend INSERE {type:id} no texto\n * 7. Backend recebe e valida tudo\n */\n\nimport { useEffect, useRef, useState } from \"react\";\nimport {\n  Command,\n  CommandEmpty,\n  CommandGroup,\n  CommandInput,\n  CommandItem,\n  CommandList,\n} from \"@/components/ui/command\";\nimport {\n  Popover,\n  PopoverContent,\n  PopoverTrigger,\n} from \"@/components/ui/popover\";\nimport { Entity, EntityType } from \"@/types/models\";\nimport { useEntityStore } from \"@/stores/entityStore\";\nimport { EntityBadge } from \"./EntityBadge\";\n\ninterface EntitySelectorProps {\n  /**\n   * Quando usuário seleciona uma entidade\n   * Frontend passa:\n   * - entity: a entidade completa\n   * - Frontend será RESPONSÁVEL de inserir no textarea\n   */\n  onSelect: (entity: Entity) => void;\n\n  // Opcional: filtrar por tipo\n  entityType?: EntityType;\n\n  // Opcional: placeholder\n  placeholder?: string;\n\n  // Se deve abrir dropdown automaticamente\n  isOpen?: boolean;\n  onOpenChange?: (open: boolean) => void;\n\n  // Query inicial (do autocomplete)\n  initialQuery?: string;\n}\n\nexport function EntitySelector({\n  onSelect,\n  entityType,\n  placeholder = \"Buscar entidade...\",\n  isOpen = false,\n  onOpenChange,\n  initialQuery = \"\",\n}: EntitySelectorProps) {\n  const [open, setOpen] = useState(isOpen);\n  const [query, setQuery] = useState(initialQuery);\n  const { search, lastSearchResults } = useEntityStore();\n  const commandRef = useRef<HTMLDivElement>(null);\n\n  // Busca automaticamente ao mudar query\n  useEffect(() => {\n    const timer = setTimeout(() => {\n      if (query.trim()) {\n        search(query, entityType);\n      }\n    }, 200); // Debounce\n\n    return () => clearTimeout(timer);\n  }, [query, entityType, search]);\n\n  const handleSelect = (entity: Entity) => {\n    onSelect(entity);\n    setOpen(false);\n    setQuery(\"\");\n  };\n\n  const handleOpenChange = (newOpen: boolean) => {\n    setOpen(newOpen);\n    onOpenChange?.(newOpen);\n  };\n\n  return (\n    <Popover open={open} onOpenChange={handleOpenChange}>\n      <PopoverTrigger asChild>\n        {/* Não renderiza um botão, apenas ativa o popover */}\n        <div />\n      </PopoverTrigger>\n      <PopoverContent className=\"w-[300px] p-0\" align=\"start\">\n        <Command>\n          <CommandInput\n            placeholder={placeholder}\n            value={query}\n            onValueChange={setQuery}\n            autoFocus\n          />\n          <CommandList>\n            {lastSearchResults.length === 0 && query.trim() && (\n              <CommandEmpty>Nenhuma entidade encontrada</CommandEmpty>\n            )}\n\n            {lastSearchResults.length > 0 && (\n              <CommandGroup>\n                {lastSearchResults.map((entity) => (\n                  <CommandItem\n                    key={entity.id}\n                    value={entity.id}\n                    onSelect={() => handleSelect(entity)}\n                  >\n                    <EntityBadge entity={entity} />\n                  </CommandItem>\n                ))}\n              </CommandGroup>\n            )}\n          </CommandList>\n        </Command>\n      </PopoverContent>\n    </Popover>\n  );\n}\n