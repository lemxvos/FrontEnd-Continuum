/**\n * EntityNetwork - Visualiza√ß√£o de rede de relacionamentos\n * Mostra entidades como n√≥s conectados por linhas representando for√ßa de conex√£o\n */\n\nimport { useState, useEffect, useRef } from \"react\";\nimport { useParams, useNavigate } from \"react-router-dom\";\nimport api from \"@/lib/axios\";\nimport { Button } from \"@/components/ui/button\";\nimport { Skeleton } from \"@/components/ui/skeleton\";\nimport { toast } from \"sonner\";\nimport { ZoomIn, ZoomOut, RotateCcw } from \"lucide-react\";\n\ninterface NetNode {\n  id: string;\n  name: string;\n  type: string;\n  x?: number;\n  y?: number;\n  vx?: number;\n  vy?: number;\n}\n\ninterface NetConnection {\n  source: string;\n  target: string;\n  strength: number;\n}\n\ninterface NetworkData {\n  nodes: NetNode[];\n  connections: NetConnection[];\n}\n\nconst TYPE_COLORS: Record<string, string> = {\n  PERSON: \"#3b82f6\",\n  HABIT: \"#10b981\",\n  PROJECT: \"#f97316\",\n  GOAL: \"#8b5cf6\",\n  DREAM: \"#ec4899\",\n  EVENT: \"#f59e0b\",\n  CUSTOM: \"#64748b\",\n};\n\nexport function EntityNetwork() {\n  const { id } = useParams<{ id: string }>();\n  const navigate = useNavigate();\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const [network, setNetwork] = useState<NetworkData | null>(null);\n  const [loading, setLoading] = useState(true);\n  const [zoom, setZoom] = useState(1);\n  const [offsetX, setOffsetX] = useState(0);\n  const [offsetY, setOffsetY] = useState(0);\n  const [hoveredNode, setHoveredNode] = useState<string | null>(null);\n\n  useEffect(() => {\n    loadNetwork();\n  }, [id]);\n\n  const loadNetwork = async () => {\n    setLoading(true);\n    try {\n      const { data } = await api.get(\n        id ? `/api/entities/${id}/network` : `/api/metrics/network`\n      );\n      \n      // Initialize positions\n      const nodes = data.nodes.map((node, idx) => ({\n        ...node,\n        x: Math.cos((idx / data.nodes.length) * Math.PI * 2) * 200,\n        y: Math.sin((idx / data.nodes.length) * Math.PI * 2) * 200,\n        vx: 0,\n        vy: 0,\n      }));\n\n      setNetwork({ nodes, connections: data.connections });\n      animate(nodes, data.connections);\n    } catch (err: any) {\n      toast.error(err.response?.data?.message || \"Erro ao carregar rede\");\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const animate = (nodes: NetNode[], connections: NetConnection[]) => {\n    let animationId: number;\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n\n    const ctx = canvas.getContext(\"2d\");\n    if (!ctx) return;\n\n    const simulate = () => {\n      // Force simulation\n      for (let i = 0; i < nodes.length; i++) {\n        let fx = 0;\n        let fy = 0;\n\n        // Repulsion from other nodes\n        for (let j = 0; j < nodes.length; j++) {\n          if (i === j) continue;\n          const dx = (nodes[j].x || 0) - (nodes[i].x || 0);\n          const dy = (nodes[j].y || 0) - (nodes[i].y || 0);\n          const dist = Math.hypot(dx, dy) || 1;\n          const force = 300 / (dist * dist);\n          fx -= (dx / dist) * force;\n          fy -= (dy / dist) * force;\n        }\n\n        // Attraction to connected nodes\n        for (const conn of connections) {\n          if (conn.source === nodes[i].id) {\n            const target = nodes.find((n) => n.id === conn.target);\n            if (target) {\n              const dx = (target.x || 0) - (nodes[i].x || 0);\n              const dy = (target.y || 0) - (nodes[i].y || 0);\n              const dist = Math.hypot(dx, dy) || 1;\n              const force = (conn.strength * 50) / dist;\n              fx += (dx / dist) * force;\n              fy += (dy / dist) * force;\n            }\n          } else if (conn.target === nodes[i].id) {\n            const source = nodes.find((n) => n.id === conn.source);\n            if (source) {\n              const dx = (source.x || 0) - (nodes[i].x || 0);\n              const dy = (source.y || 0) - (nodes[i].y || 0);\n              const dist = Math.hypot(dx, dy) || 1;\n              const force = (conn.strength * 50) / dist;\n              fx += (dx / dist) * force;\n              fy += (dy / dist) * force;\n            }\n          }\n        }\n\n        // Damping\n        (nodes[i].vx || 0) = ((nodes[i].vx || 0) + fx * 0.005) * 0.99;\n        (nodes[i].vy || 0) = ((nodes[i].vy || 0) + fy * 0.005) * 0.99;\n        (nodes[i].x || 0) += nodes[i].vx || 0;\n        (nodes[i].y || 0) += nodes[i].vy || 0;\n      }\n\n      // Draw\n      ctx.fillStyle = \"rgba(0,0,0,0.05)\";\n      ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n      ctx.save();\n      ctx.translate(canvas.width / 2 + offsetX, canvas.height / 2 + offsetY);\n      ctx.scale(zoom, zoom);\n\n      // Draw connections\n      for (const conn of connections) {\n        const source = nodes.find((n) => n.id === conn.source);\n        const target = nodes.find((n) => n.id === conn.target);\n        if (!source || !target) continue;\n\n        ctx.strokeStyle = `rgba(100, 116, 139, ${conn.strength * 0.5})`;\n        ctx.lineWidth = conn.strength * 3;\n        ctx.beginPath();\n        ctx.moveTo(source.x || 0, source.y || 0);\n        ctx.lineTo(target.x || 0, target.y || 0);\n        ctx.stroke();\n      }\n\n      // Draw nodes\n      for (const node of nodes) {\n        const radius = hoveredNode === node.id ? 8 : 6;\n        ctx.fillStyle = TYPE_COLORS[node.type] || \"#64748b\";\n        ctx.beginPath();\n        ctx.arc(node.x || 0, node.y || 0, radius, 0, Math.PI * 2);\n        ctx.fill();\n\n        // Label on hover\n        if (hoveredNode === node.id) {\n          ctx.fillStyle = \"#fff\";\n          ctx.font = \"12px sans-serif\";\n          ctx.textAlign = \"center\";\n          ctx.fillText(node.name, (node.x || 0), (node.y || 0) + 15);\n        }\n      }\n\n      ctx.restore();\n      animationId = requestAnimationFrame(simulate);\n    };\n\n    simulate();\n    return () => cancelAnimationFrame(animationId);\n  };\n\n  const handleCanvasClick = (e: React.MouseEvent<HTMLCanvasElement>) => {\n    if (!network || !canvasRef.current) return;\n\n    const canvas = canvasRef.current;\n    const rect = canvas.getBoundingClientRect();\n    const x = (e.clientX - rect.left - canvas.width / 2 - offsetX) / zoom;\n    const y = (e.clientY - rect.top - canvas.height / 2 - offsetY) / zoom;\n\n    for (const node of network.nodes) {\n      const dx = (node.x || 0) - x;\n      const dy = (node.y || 0) - y;\n      if (Math.hypot(dx, dy) < 8) {\n        navigate(`/entities/${node.id}`);\n        return;\n      }\n    }\n  };\n\n  const handleCanvasMouseMove = (e: React.MouseEvent<HTMLCanvasElement>) => {\n    if (!network || !canvasRef.current) return;\n\n    const canvas = canvasRef.current;\n    const rect = canvas.getBoundingClientRect();\n    const x = (e.clientX - rect.left - canvas.width / 2 - offsetX) / zoom;\n    const y = (e.clientY - rect.top - canvas.height / 2 - offsetY) / zoom;\n\n    for (const node of network.nodes) {\n      const dx = (node.x || 0) - x;\n      const dy = (node.y || 0) - y;\n      if (Math.hypot(dx, dy) < 8) {\n        setHoveredNode(node.id);\n        return;\n      }\n    }\n    setHoveredNode(null);\n  };\n\n  if (loading) return <Skeleton className=\"h-96 rounded-lg\" />;\n\n  return (\n    <div className=\"space-y-4\">\n      <div className=\"flex items-center justify-between\">\n        <h2 className=\"text-lg font-bold\">üåê Rede de Entidades</h2>\n        <div className=\"flex gap-2\">\n          <Button\n            size=\"sm\"\n            variant=\"outline\"\n            onClick={() => setZoom((z) => Math.min(z + 0.1, 3))}\n          >\n            <ZoomIn className=\"h-4 w-4\" />\n          </Button>\n          <Button\n            size=\"sm\"\n            variant=\"outline\"\n            onClick={() => setZoom((z) => Math.max(z - 0.1, 0.5))}\n          >\n            <ZoomOut className=\"h-4 w-4\" />\n          </Button>\n          <Button\n            size=\"sm\"\n            variant=\"outline\"\n            onClick={() => {\n              setZoom(1);\n              setOffsetX(0);\n              setOffsetY(0);\n            }}\n          >\n            <RotateCcw className=\"h-4 w-4\" />\n          </Button>\n        </div>\n      </div>\n\n      <canvas\n        ref={canvasRef}\n        width={800}\n        height={400}\n        onClick={handleCanvasClick}\n        onMouseMove={handleCanvasMouseMove}\n        onMouseLeave={() => setHoveredNode(null)}\n        className=\"w-full border border-border rounded-lg bg-background cursor-grab active:cursor-grabbing\"\n      />\n\n      <div className=\"grid grid-cols-2 md:grid-cols-4 gap-2 text-xs\">\n        {Object.entries(TYPE_COLORS).map(([type, color]) => (\n          <div key={type} className=\"flex items-center gap-2\">\n            <div\n              className=\"w-3 h-3 rounded-full\"\n              style={{ backgroundColor: color }}\n            />\n            <span className=\"text-muted-foreground\">{type.toLowerCase()}</span>\n          </div>\n        ))}\n      </div>\n    </div>\n  );\n}\n