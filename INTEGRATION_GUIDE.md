# ðŸ”Œ Integration Guide for Backend Developers\n\n## Quick Start for Backend\n\n### Step 1: Implement Basic Dashboard Endpoint\n```typescript\n// GET /api/metrics/dashboard\nGET controller.metrics.dashboard = async (req, res) => {\n  const userId = req.user.id;\n  \n  // Count operations\n  const totalNotes = await Note.countDocuments({ userId });\n  const totalEntities = await Entity.countDocuments({ userId });\n  \n  // Group by type\n  const entitiesByType = await Entity.aggregate([\n    { $match: { userId } },\n    { $group: { _id: '$type', count: { $sum: 1 } } }\n  ]);\n  \n  // Recent notes\n  const now = new Date();\n  const weekAgo = new Date(now - 7 * 24 * 60 * 60 * 1000);\n  const monthAgo = new Date(now - 30 * 24 * 60 * 60 * 1000);\n  \n  const thisWeekNotes = await Note.countDocuments({\n    userId,\n    createdAt: { $gte: weekAgo }\n  });\n  \n  const thisMonthNotes = await Note.countDocuments({\n    userId,\n    createdAt: { $gte: monthAgo }\n  });\n  \n  res.json({\n    totalNotes,\n    totalEntities,\n    totalPeople: entitiesByType.find(e => e._id === 'PERSON')?.count || 0,\n    // ... other fields\n  });\n};\n```\n\n### Step 2: Build Co-occurrence Index\n```typescript\n// Helper function to calculate entity co-occurrence\nasync function calculateCoOccurrence(userId, entityA, entityB) {\n  // Find notes mentioning both entities\n  const commonNotes = await Note.countDocuments({\n    userId,\n    mentions: { $all: [entityA, entityB] }\n  });\n  \n  // Find notes mentioning at least one\n  const totalNotes = await Note.countDocuments({\n    userId,\n    mentions: { $in: [entityA, entityB] }\n  });\n  \n  // Strength = common / total (normalized 0-1)\n  return commonNotes / Math.max(totalNotes, 1);\n}\n```\n\n### Step 3: Network Graph Implementation\n```typescript\n// GET /api/metrics/network\nGET controller.metrics.network = async (req, res) => {\n  const userId = req.user.id;\n  const limit = req.query.limit || 50;\n  const minStrength = req.query.minStrength || 0.3;\n  \n  // Get top entities by mention count\n  const topEntities = await Note.aggregate([\n    { $match: { userId } },\n    { $unwind: '$mentions' },\n    { $group: {\n        _id: '$mentions',\n        count: { $sum: 1 }\n      }\n    },\n    { $sort: { count: -1 } },\n    { $limit: limit }\n  ]);\n  \n  const entityIds = topEntities.map(e => e._id);\n  \n  // Get full entity data\n  const nodes = await Entity.find({\n    _id: { $in: entityIds },\n    userId\n  }).select('_id name type');\n  \n  // Build connections\n  const connections = [];\n  for (let i = 0; i < entityIds.length; i++) {\n    for (let j = i + 1; j < entityIds.length; j++) {\n      const strength = await calculateCoOccurrence(\n        userId,\n        entityIds[i],\n        entityIds[j]\n      );\n      \n      if (strength >= minStrength) {\n        connections.push({\n          source: entityIds[i],\n          target: entityIds[j],\n          strength\n        });\n      }\n    }\n  }\n  \n  res.json({ nodes, connections });\n};\n```\n\n### Step 4: Insights Generation (Optional but Recommended)\n```typescript\n// GET /api/metrics/insights\nGET controller.metrics.insights = async (req, res) => {\n  const userId = req.user.id;\n  const insights = [];\n  \n  // Insight 1: Activity trend\n  const thisWeek = await Note.countDocuments({\n    userId,\n    createdAt: { $gte: new Date(Date.now() - 7*24*60*60*1000) }\n  });\n  \n  const lastWeek = await Note.countDocuments({\n    userId,\n    createdAt: {\n      $gte: new Date(Date.now() - 14*24*60*60*1000),\n      $lt: new Date(Date.now() - 7*24*60*60*1000)\n    }\n  });\n  \n  if (thisWeek > lastWeek * 1.3) {\n    insights.push({\n      title: 'Burst in activity',\n      description: `You created ${thisWeek} notes, ${Math.round((thisWeek-lastWeek)/lastWeek*100)}% more than last week`,\n      type: 'success'\n    });\n  }\n  \n  res.json({\n    recentInsights: insights,\n    recommendations: [],\n    patterns: []\n  });\n};\n```\n\n---\n\n## MongoDB Schema Recommendations\n\n```typescript\n// Entity Schema\nconst entitySchema = {\n  _id: ObjectId,\n  userId: ObjectId,        // Foreign key\n  name: String,            // \"John Doe\"\n  type: String,            // \"PERSON\" | \"HABIT\" | \"PROJECT\" | etc\n  description: String,\n  color: String,           // Hex color for UI\n  icon: String,            // Emoji or icon name\n  createdAt: Date,\n  updatedAt: Date,\n  _mentions: Number        // Denormalized count for speed\n};\n\n// Note-Entity Junction (for efficient co-occurrence queries)\nconst noteEntitySchema = {\n  noteId: ObjectId,\n  entityId: ObjectId,\n  userId: ObjectId,        // For efficient user-scoped queries\n  createdAt: Date          // Inherit from note\n};\n\n// Indexes needed:\ndb.entities.createIndex({ userId: 1, type: 1 });\ndb.entities.createIndex({ userId: 1, _mentions: -1 });\ndb.noteEntities.createIndex({ userId: 1, entityId: 1 });\ndb.noteEntities.createIndex({ entityId: 1, noteId: 1 });\n```\n\n---\n\n## Frontend Testing Checklist\n\n### Before Connecting Backend\nFrontend already has:\n- âœ… Try/catch error handling\n- âœ… Loading states (Skeleton)\n- âœ… Empty states\n- âœ… Toast notifications\n- âœ… Responsive layouts\n\n### When Connecting\n1. **Dashboard Page**:\n   - [ ] Stats load correctly\n   - [ ] Numbers make sense\n   - [ ] Trends calculate properly\n   - [ ] Most mentioned shows correct entity\n\n2. **Network Visualization**:\n   - [ ] Nodes render without overlapping\n   - [ ] Force simulation is smooth (60fps)\n   - [ ] Connections have correct strength\n   - [ ] Click navigation works\n   - [ ] Zoom/pan controls responsive\n\n3. **Insights Panel**:\n   - [ ] Tabs switch correctly\n   - [ ] Content loads in correct tabs\n   - [ ] Action links navigate correctly\n   - [ ] Empty states show when no data\n\n---\n\n## Performance Optimization Ideas\n\n### For Large Datasets\n\n1. **Pagination for Network**\n   ```typescript\n   // Load first 30 nodes, lazy-load more on scroll\n   const PAGE_SIZE = 30;\n   const page = req.query.page || 0;\n   const skip = page * PAGE_SIZE;\n   ```\n\n2. **Calculation Caching**\n   ```typescript\n   // Cache network for 4 hours\n   const CACHE_KEY = `network:${userId}:${limit}:${minStrength}`;\n   const cached = await redis.get(CACHE_KEY);\n   if (cached) return JSON.parse(cached);\n   \n   // ... calculate ...\n   await redis.setex(CACHE_KEY, 4*60*60, JSON.stringify(result));\n   ```\n\n3. **Batch Statistics**\n   ```typescript\n   // Use aggregation pipeline for all stats in one query\n   const stats = await Note.aggregate([\n     { $match: { userId } },\n     { $group: {\n         _id: null,\n         totalNotes: { $sum: 1 },\n         thisWeekNotes: {\n           $sum: { $cond: [\n             { $gte: ['$createdAt', weekAgo] },\n             1, 0\n           ] }\n         }\n       }\n     }\n   ]);\n   ```\n\n---\n\n## Debugging Tips\n\n### Frontend Side\n```typescript\n// Add to Dashboard.tsx to see API responses\nconst loadDashboard = async () => {\n  try {\n    const { data } = await api.get('/api/metrics/dashboard');\n    console.log('Dashboard data:', data);  // <-- Check this\n    setStats(data);\n  } catch (err) {\n    console.error('Error:', err.response?.data);\n  }\n};\n```\n\n### Backend Side\n```typescript\n// Log aggregation results\nconst result = await database.metrics.dashboard(userId);\nconsole.info('Calculated stats:', result);\nres.json(result);\n```\n\n### Network Visualization Issues\n- If nodes overlap: Reduce force simulation `repulsion` value\n- If nodes fly away: Increase `damping` value\n- If movements jerky: Reduce canvas resolution or force iterations\n\n---\n\n## Common Integration Issues\n\n### Issue: Stats don't match expectations\n**Solution**: Check Note schema mentions are saved correctly\n```typescript\n// Verify note structure\nconst note = await Note.findById(noteId);\nconsole.log(note.mentions); // Should be array of entity IDs\n```\n\n### Issue: Network has too many nodes\n**Solution**: Apply `minStrength` filter more aggressively\n```typescript\nconst minStrength = req.query.minStrength || 0.5; // Increase from 0.3\n```\n\n### Issue: Insights never load\n**Solution**: Implement basic version first\n```typescript\nres.json({\n  recentInsights: [],\n  recommendations: [],\n  patterns: [\n    { title: 'Getting started', description: 'No patterns yet' }\n  ]\n});\n```\n\n---\n\n## Next Phase: Advanced Analytics\n\nOnce basic dashboard works:\n1. Add time-series data (activity over time)\n2. Implement habit streaks\n3. Add goal progress tracking\n4. Build advanced filtering (date ranges, entity types)\n5. Export functionality (CSV, PDF)\n