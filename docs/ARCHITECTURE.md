# Arquitetura Frontend - Continuum\n\n**Data:** Fevereiro 2026  \n**Stack:** React + TypeScript + Zustand + Axios\n\n---\n\n## PRINCÃPIO FUNDAMENTAL\n\n> **Frontend Ã© BURRO. Backend Ã© CÃ‰REBRO.**\n\nâœ… Frontend:\n- Envia texto com menÃ§Ãµes `{type:id}`\n- Exibe dados jÃ¡ processados\n- Renderiza componentes\n- Gerencia formato/UX\n\nâŒ Frontend NÃƒO:\n- Parseia menÃ§Ãµes\n- Valida entidades\n- Calcula Ã­ndices\n- Infere relaÃ§Ãµes\n- Duplica lÃ³gica do backend\n\n---\n\n## ESTRUTURA DE PASTAS\n\n```\nsrc/\nâ”œâ”€â”€ types/\nâ”‚   â””â”€â”€ models.ts                 # âœ… Interfaces (contrato com backend)\nâ”œâ”€â”€ services/\nâ”‚   â”œâ”€â”€ noteService.ts            # âœ… HTTP calls para /api/notes\nâ”‚   â””â”€â”€ entityService.ts          # âœ… HTTP calls para /api/entities\nâ”œâ”€â”€ stores/\nâ”‚   â”œâ”€â”€ authStore.ts              # (jÃ¡ existe) AutenticaÃ§Ã£o\nâ”‚   â”œâ”€â”€ noteStore.ts              # âœ… Estado de notas (Zustand)\nâ”‚   â””â”€â”€ entityStore.ts            # âœ… Estado de entidades (Zustand)\nâ”œâ”€â”€ hooks/\nâ”‚   â”œâ”€â”€ useMentions.ts            # âœ… LÃ³gica de menÃ§Ãµes\nâ”‚   â””â”€â”€ use-mobile.tsx            # (jÃ¡ existe)\nâ”œâ”€â”€ components/\nâ”‚   â”œâ”€â”€ EntityBadge.tsx           # âœ… Renderiza entidade como badge\nâ”‚   â”œâ”€â”€ EntitySelector.tsx        # âœ… Autocomplete de entidades\nâ”‚   â”œâ”€â”€ MentionDisplay.tsx        # âœ… Renderiza menÃ§Ãµes em texto\nâ”‚   â”œâ”€â”€ JournalEditor.tsx         # âœ… Editor de notas com menÃ§Ãµes\nâ”‚   â”œâ”€â”€ AppLayout.tsx             # (jÃ¡ existe)\nâ”‚   â””â”€â”€ ui/                       # (jÃ¡ existe - shadcn/ui)\nâ”œâ”€â”€ pages/\nâ”‚   â”œâ”€â”€ Journal.tsx               # Lista de notas\nâ”‚   â”œâ”€â”€ JournalEditor.tsx         # PÃ¡gina editor\nâ”‚   â””â”€â”€ ... (outras pÃ¡ginas)\nâ”œâ”€â”€ lib/\nâ”‚   â”œâ”€â”€ axios.ts                  # (jÃ¡ existe) Cliente HTTP\nâ”‚   â””â”€â”€ utils.ts                  # (jÃ¡ existe) Utilidades\nâ””â”€â”€ stores/\n    â””â”€â”€ authStore.ts              # (jÃ¡ existe)\n```\n\n---\n\n## FLUXO DE DADOS\n\n### 1ï¸âƒ£ CRIANDO UMA NOTA\n\n```\nJournalEditor component\n  â†“\nUsuÃ¡rio digita: \"SaÃ­ com {person:ent_8f2a}\"\n  â†“\nClica \"Salvar\"\n  â†“\nJournalEditor.handleSave()\n  â†“\nuseNoteStore.create({ title, content, folderPath })\n  â†“\nnoteService.create() â†’ POST /api/notes\n  â†“\nBACKEND:\n- Parseia \"{person:ent_8f2a}\"\n- Valida se entidade existe\n- Valida se type bate\n- Busca Entity({ id: \"ent_8f2a\", ... })\n- Atualiza Ã­ndices\n- Retorna Note com entities[] preenchido\n  â†“\nFrontend recebe:\n{\n  id: \"note_abc\",\n  content: \"SaÃ­ com {person:ent_8f2a}\",\n  entities: [\n    { id: \"ent_8f2a\", type: \"person\", name: \"Emilly\", icon: \"ğŸ‘©\" }\n  ]\n}\n  â†“\nuseNoteStore.notes += [newNote]\n  â†“\nComponentes re-renderizam com dados sincronizados\n```\n\n### 2ï¸âƒ£ EDITANDO UMA NOTA\n\n```\nJournalEditor monta com noteId\n  â†“\nuseNoteStore.fetchOne(noteId)\n  â†“\nnoteService.getOne(id) â†’ GET /api/notes/:id\n  â†“\nFrontend carrega conteÃºdo existente\n  â†“\nUsuÃ¡rio modifica, adiciona mais menÃ§Ãµes\n  â†“\nClica Salvar\n  â†“\nuseNoteStore.update(noteId, { title, content, folderPath })\n  â†“\nnoteService.update(id, payload) â†’ PUT /api/notes/:id\n  â†“\nBACKEND:\n- Remove entradas antigas do Ã­ndice\n- Parseia novo content\n- Busca entidades novas\n- Atualiza Ã­ndices\n- Retorna nota com entities[] recalculado\n  â†“\nFrontend sincroniza\n```\n\n### 3ï¸âƒ£ AUTOCOMPLETE DE ENTIDADES\n\n```\nJournalEditor em uso\n  â†“\nUsuÃ¡rio digita: \"SaÃ­ com {pe\"\n  â†“\nuseMentionAutocompleteState() detecta padrÃ£o\n  â†“\nMostra EntitySelector component\n  â†“\nuseEntityStore.search(\"pe\", type?: undefined)\n  â†“\nentityService.autocomplete(\"pe\") â†’ GET /api/entities/search?q=pe\n  â†“\nBACKEND retorna:\n[\n  { id: \"ent_8f2a\", name: \"Pessoa X\", type: \"person\", icon: \"ğŸ‘©\" },\n  { id: \"ent_91cd\", name: \"Projeto Y\", type: \"project\", icon: \"ğŸ“Š\" }\n]\n  â†“\nEntitySelector renderiza dropdown\n  â†“\nUsuÃ¡rio clica em \"Pessoa X\"\n  â†“\nhandleEntitySelect(entity)\n  â†“\ninsertMentionAtPosition(content, cursor, \"person\", \"ent_8f2a\")\n  â†“\nContent â† \"SaÃ­ com {person:ent_8f2a}\"\n  â†“\nTextarea re-renderiza\n  â†“\nMentionDisplay mostra preview comcertificado badge [ğŸ‘© Pessoa X]\n```\n\n---\n\n## CAMADAS\n\n### 1. TYPES (src/types/models.ts)\n\n**Responsabilidade:** Definir o contrato com o backend\n\n```typescript\n// Entity: Como o backend retorna entidades\ninterface Entity {\n  id: string;\n  type: EntityType;\n  name: string;\n  icon?: string;\n  color?: string;\n  createdAt: string;\n  updatedAt: string;\n}\n\n// Note: Como o backend retorna notas (COM entities resolvidas!)\ninterface Note {\n  id: string;\n  title: string;\n  content: string;  // Raw text com {type:id}\n  entities: Entity[]; // JÃ PROCESSADO PELO BACKEND\n  folderPath: string;\n  createdAt: string;\n  updatedAt: string;\n}\n```\n\nğŸ’¡ **Nunca transforme esses tipos!**\n\n---\n\n### 2. SERVICES (src/services/)\n\n#### noteService.ts\n\n**Responsabilidade:** Chamadas HTTP para /api/notes\n\n```typescript\nnoteService.create(payload: CreateNotePayload): Promise<Note>\nnoteService.update(id, payload: UpdateNotePayload): Promise<Note>\nnoteService.delete(id): Promise<void>\nnoteService.getOne(id): Promise<Note>\nnoteService.list(options: { page?, pageSize?, folderPath? }): Promise<PaginatedResponse<Note>>\nnoteService.search(options: { entityId?, folderPath?, dateFrom?, dateTo? }): Promise<Note[]>\nnoteService.getFolders(): Promise<Folder[]>\n```\n\nâœ… **Simples HTTP**  \nâŒ **Sem transformaÃ§Ãµes**  \nâŒ **Sem validaÃ§Ãµes**  \n\n#### entityService.ts\n\n**Responsabilidade:** Chamadas HTTP para /api/entities\n\n```typescript\nentityService.create(payload): Promise<Entity>\nentityService.update(id, payload): Promise<Entity>\nentityService.delete(id): Promise<void>\nentityService.getOne(id): Promise<Entity>\nentityService.listAll(options?: { type?, search? }): Promise<Entity[]>  // PARA AUTOCOMPLETE\nentityService.listByType(type): Promise<Entity[]>\nentityService.autocomplete(query, options?: { type?, limit? }): Promise<Entity[]>  // AUTOCOMPLETE em tempo real\nentityService.getStats(id): Promise<EntityStats>\n```\n\n---\n\n### 3. STORES (src/stores/)\n\n#### useNoteStore (Zustand)\n\n**Responsabilidade:** Cache de notas + operaÃ§Ãµes\n\n```typescript\nconst { \n  notes,              // Array de notas em cache\n  isLoading,\n  error,\n  currentNote,        // Nota sendo editada\n  \n  // AÃ§Ãµes\n  fetchList,          // GET /api/notes?page=...\n  fetchOne,           // GET /api/notes/:id\n  search,             // GET /api/notes/search?...\n  create,             // POST /api/notes\n  update,             // PUT /api/notes/:id\n  delete,             // DELETE /api/notes/:id\n  setCurrentNote,\n  reset\n} = useNoteStore();\n```\n\n#### useEntityStore (Zustand)\n\n**Responsabilidade:** Cache de entidades + operaÃ§Ãµes\n\n```typescript\nconst {\n  entities,          // Array de todas as entidades\n  isLoading,\n  error,\n  lastSearchResults, // Resultado do Ãºltimo autocomplete\n  \n  // AÃ§Ãµes\n  fetch,             // GET /api/entities\n  fetchByType,       // GET /api/entities/type/:type\n  search,            // GET /api/entities/search\n  create,            // POST /api/entities\n  update,            // PATCH /api/entities/:id\n  delete,            // DELETE /api/entities/:id\n  getOne,            // Busca no cache local\n  reset\n} = useEntityStore();\n```\n\n---\n\n### 4. HOOKS (src/hooks/useMentions.ts)\n\n**Responsabilidade:** LÃ³gica de menÃ§Ãµes (sem validaÃ§Ã£o)\n\n```typescript\n// Tokeniza texto em partes (text | mention)\nuseMentionTokens(content: string): MentionToken[]\n// \"SaÃ­ com {person:ent_8f2a}\" â†’ [{ type: \"text\", value: \"SaÃ­ com \" }, { type: \"mention\", ...}]\n\n// Extrai array de menÃ§Ãµes\nuseMentionedEntityReferences(content: string): Array<{ type, id }>\n// \"SaÃ­ com {person:ent_8f2a}\" â†’ [{ type: \"person\", id: \"ent_8f2a\" }]\n\n// Formata menÃ§Ã£o\nformatMention(type: string, id: string): string\n// \"person\", \"ent_8f2a\" â†’ \"{person:ent_8f2a}\"\n\n// Insere menÃ§Ã£o em posiÃ§Ã£o\ninsertMentionAtPosition(text, position, type, id): string\n// \"SaÃ­ com \", 8, \"person\", \"ent_8f2a\" â†’ \"SaÃ­ com {person:ent_8f2a}\"\n\n// Valida FORMAT (nÃ£o semÃ¢ntica!)\nisValidMentionFormat(text: string): boolean\n// \"{person:ent_8f2a}\" â†’ true, \"xxx\" â†’ false\n\n// Conta menÃ§Ãµes\nuseMentionCount(content: string): number\n// \"SaÃ­ com {person:ent_8f2a} e {project:ent_91ab}\" â†’ 2\n\n// Detecta autocomplete state\nuseMentionAutocompleteState(text, cursorPosition): AutocompleteMention | null\n// Detecta se usuÃ¡rio estÃ¡ digitando {pe ou @jo\n```\n\n---\n\n### 5. COMPONENTES (src/components/)\n\n#### EntityBadge.tsx\n\n```jsx\n<EntityBadge \n  entity={{ id: \"ent_8f2a\", name: \"Emilly\", icon: \"ğŸ‘©\", color: \"#ec4899\" }}\n  onClick={() => navigateToEntity()}\n  removable={true}\n  onRemove={() => deleteEntity()}\n/>\n// Renderiza: [ğŸ‘© Emilly] com cor de fundo\n```\n\n#### EntitySelector.tsx\n\n```jsx\n<EntitySelector\n  isOpen={true}\n  initialQuery=\"pe\"\n  onSelect={(entity) => insertMentionInEditor(entity)}\n/>\n// Autocomplete dropdown que busca entidades em tempo real\n```\n\n#### MentionDisplay.tsx\n\n```jsx\n<MentionDisplay\n  content=\"SaÃ­ com {person:ent_8f2a}\"\n  entities={[{ id: \"ent_8f2a\", name: \"Emilly\", ... }]}\n  onEntityClick={(entity) => navigateTo(entity)}\n/>\n// Renderiza: \"SaÃ­ com [ğŸ‘© Emilly]\"\n```\n\n#### JournalEditor.tsx\n\n**Componente mais importante!**\n\n```jsx\n<JournalEditor\n  noteId=\"note_abc\"           // Se undefined = novo\n  defaultFolder=\"inbox\"\n  onSaveSuccess={(note) => navigate(`/notes/${note.id}`)}\n  onCancel={() => navigate('/journal')}\n/>\n```\n\n**Fluxo interno:**\n1. Textarea com texto\n2. Detecta autocomplete (useMentionAutocompleteState)\n3. Mostra EntitySelector\n4. UsuÃ¡rio seleciona entidade\n5. Insere {type:id} no texto\n6. Preview com MentionDisplay\n7. Clica Salvar\n8. noteStore.create() ou update()\n9. Backend processa\n10. Retorna com entities[]\n11. Re-renderiza\n\n---\n\n## EXEMPLOS DE USO\n\n### Exemplo 1: Criar uma nota\n\n```tsx\nimport { useNoteStore } from '@/stores/noteStore';\nimport { JournalEditor } from '@/components/JournalEditor';\n\nfunction JournalPage() {\n  const { create } = useNoteStore();\n\n  return (\n    <JournalEditor\n      onSaveSuccess={(note) => {\n        console.log('Nota criada:', note.id);\n        // note.entities jÃ¡ vem preenchido pelo backend\n      }}\n    />\n  );\n}\n```\n\n### Exemplo 2: Listar notas com entidades\n\n```tsx\nimport { useNoteStore } from '@/stores/noteStore';\nimport { MentionDisplay } from '@/components/MentionDisplay';\n\nfunction NotesList() {\n  const { notes, fetchList } = useNoteStore();\n\n  useEffect(() => {\n    fetchList({ page: 1, pageSize: 20 });\n  }, []);\n\n  return (\n    <div>\n      {notes.map((note) => (\n        <div key={note.id}>\n          <h2>{note.title}</h2>\n          {/* Renderiza conteÃºdo COM menÃ§Ãµes resolvidas */}\n          <MentionDisplay \n            content={note.content} \n            entities={note.entities} \n          />\n        </div>\n      ))}\n    </div>\n  );\n}\n```\n\n### Exemplo 3: Buscar notas por entidade\n\n```tsx\nfunction EntityDetailPage({ entityId }) {\n  const { search } = useNoteStore();\n\n  useEffect(() => {\n    // Busca todas as notas que mencionam essa entidade\n    search({ entityId });\n  }, [entityId]);\n\n  // Frontend apenas exibe\n  // Backend fez todo o trabalho de parsing/indexing\n}\n```\n\n### Exemplo 4: Autocomplete em tempo real\n\n```tsx\nfunction EntityAutoComplete() {\n  const { search, lastSearchResults } = useEntityStore();\n  const [query, setQuery] = useState('');\n\n  useEffect(() => {\n    if (query.trim()) {\n      search(query);\n    }\n  }, [query]);\n\n  return (\n    <div>\n      <input onChange={(e) => setQuery(e.target.value)} />\n      {lastSearchResults.map((entity) => (\n        <EntityBadge key={entity.id} entity={entity} />\n      ))}\n    </div>\n  );\n}\n```\n\n---\n\n## CONTRATO COM BACKEND\n\n### POST /api/notes\n\n**Request:**\n```json\n{\n  \"title\": \"Hoje foi bom\",\n  \"content\": \"SaÃ­ com {person:ent_8f2a} e {project:ent_91ab}\",\n  \"folderPath\": \"vida/amigos\"\n}\n```\n\n**Response:**\n```json\n{\n  \"id\": \"note_abc123\",\n  \"title\": \"Hoje foi bom\",\n  \"content\": \"SaÃ­ com {person:ent_8f2a} e {project:ent_91ab}\",\n  \"folderPath\": \"vida/amigos\",\n  \"entities\": [\n    {\n      \"id\": \"ent_8f2a\",\n      \"type\": \"person\",\n      \"name\": \"Emilly\",\n      \"icon\": \"ğŸ‘©\",\n      \"color\": \"#ec4899\"\n    },\n    {\n      \"id\": \"ent_91ab\",\n      \"type\": \"project\",\n      \"name\": \"CafÃ©\",\n      \"icon\": \"â˜•\",\n      \"color\": \"#f97316\"\n    }\n  ],\n  \"createdAt\": \"2026-02-18T10:00:00Z\",\n  \"updatedAt\": \"2026-02-18T10:00:00Z\"\n}\n```\n\n### GET /api/entities/search?q=em&limit=10\n\n**Response:**\n```json\n[\n  {\n    \"id\": \"ent_8f2a\",\n    \"type\": \"person\",\n    \"name\": \"Emilly\",\n    \"icon\": \"ğŸ‘©\",\n    \"color\": \"#ec4899\",\n    \"createdAt\": \"...\",\n    \"updatedAt\": \"...\"\n  }\n]\n```\n\n### GET /api/entities/:id/stats\n\n**Response:**\n```json\n{\n  \"entityId\": \"ent_8f2a\",\n  \"name\": \"Emilly\",\n  \"type\": \"person\",\n  \"mentionCount\": 42,\n  \"lastMentionedAt\": \"2026-02-18T10:00:00Z\",\n  \"firstMentionedAt\": \"2026-01-01T10:00:00Z\",\n  \"relatedEntities\": [\n    {\n      \"entityId\": \"ent_91ab\",\n      \"name\": \"CafÃ©\",\n      \"coocurrenceCount\": 12\n    }\n  ]\n}\n```\n\n---\n\n## REGRAS ABSOLUTAS\n\n### âœ… FAÃ‡A\n\n- âœ… Use `{type:id}` como padrÃ£o de menÃ§Ã£o\n- âœ… Envie content com menÃ§Ãµes para o backend\n- âœ… Receba entities jÃ¡ processadas\n- âœ… Renderize com MentionDisplay\n- âœ… Confie em dados do backend\n- âœ… Use useNoteStore e useEntityStore como fonte Ãºnica de verdade\n- âœ… Cache agressivamente (Zustand)\n- âœ… Atualize cache apÃ³s mutaÃ§Ãµes\n- âœ… Exiba erros do backend com clareza\n\n### âŒ NÃƒO FAÃ‡A\n\n- âŒ NÃ£o parseia menÃ§Ãµes a nÃ£o ser para display\n- âŒ NÃ£o valida se Entity existe\n- âŒ NÃ£o calcula contagens\n- âŒ NÃ£o transforma tipos\n- âŒ NÃ£o mova lÃ³gica semÃ¢ntica pro frontend\n- âŒ NÃ£o tente \"corrigir\" menÃ§Ãµes invÃ¡lidas\n- âŒ NÃ£o duplique regras do backend\n- âŒ NÃ£o ignore erros do backend\n- âŒ NÃ£o assume dados que nÃ£o recebeu\n\n---\n\n## PRÃ“XIMOS PASSOS\n\n1. **Conectar Pages**\n   - JournalPage (lista)\n   - JournalEditorPage (editor)\n   - EntityListPage (lista categorizada)\n   - ConnectionsPage (grafo de relaÃ§Ãµes)\n\n2. **Integrar EntitySelector com JournalEditor**\n   - Detectar autocomplete\n   - Abrir dropdown\n   - Inserir menÃ§Ã£o\n\n3. **Testes**\n   - useMentions hooks\n   - Store actions\n   - Componente JournalEditor\n\n4. **Backend Contract**\n   - Confirmrar rotas\n   - Confirmrar payloads\n   - Error handling\n\n---\n\n## CHECKLIST DE BOAS PRÃTICAS\n\n- [ ] Types definidos para cada response\n- [ ] Services com mÃ©todos bem nomeados\n- [ ] Stores com aÃ§Ãµes sÃ­ncrono/async claras\n- [ ] Componentes com interfaces bem documentadas\n- [ ] Hooks reutilizÃ¡veis\n- [ ] Zero lÃ³gica de negÃ³cio no componente\n- [ ] Cache sincronizado apÃ³s mutaÃ§Ãµes\n- [ ] Errors tratados e exibidos\n- [ ] Loading states em todos os lugares certos\n- [ ] Sem duplicaÃ§Ã£o entre layers\n\n---\n\n## SUPORTE\n\nPara dÃºvidas sobre responsabilidade de camadas:\n\n**Frontend** â†’ Types, Services, Stores, Hooks, Componentes  \n**Backend** â†’ Parsing, ValidaÃ§Ã£o, Indexing, CÃ¡lculos semÃ¢nticos  \n\nSempre: **\"Quem valida/processa? Backend.\"**\n"